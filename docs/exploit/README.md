# Exploit
## How to create an exploit

**Required methods**

These methods needs to be in every exploit script.
```
def get_vuln_data():
def is_vulnerable(target):
def get_methods():
def is_auth_required():
def get_author():
def get_thanks():
```

**Optional methods**

These are optional, however each exploit script needs to contain atleast one of these to work.
```
def rce(instruction, args):
def lfi(instruction, args):
def rfi(instruction, args):
def sqle(instruction, args):
def sqlr(instruction, args):
```

## Required methods details

### get_vuln_data()
This needs to return an object that tells HackWP how to know if the target is vulnerable or not. This is a more `stealthy` check for vulnerable targets than using the more aggressive `is_vulnerable(target)`.
**Sample definition**
```
def get_vuln_data():
    return {
        'core': False,
        'theme': {
            'slug':     'hello-elementor',
            'versions': {
                'from': '*',
                'to':   '1.9.6'
            }
        },
        'plugins': {
            {
                'slug':     'elementor-pro',
                'versions': {
                    'from': '1.2.1',
                    'to':   '1.2.3.1'
                }
            }
        },
        'custom': False
    }
```
If `custom` is set to `True`, HackWP will use the more aggressive `is_vulnerable(target)` function if the state cannot be detected simply by softwares and versions.

### is_vulnerable(target)
This is an aggressive check if the target is vulnerable.<br />
ie if the vulnerability needs to be tested live before we know.

**Sample definition**
```
def is_vulnerable(target):
    # Try out RCE on target
    resp = rce('<?php echo "VULNERABLE"; ?>', {})
    # If the string "VULNERABLE" is present in the output
    # the target is vulnerable to RCE
    return re.search('VULNERABLE', resp)
```

### get_methods()
Get methods that this exploit can create / use

**Sample definition**
```
def get_methods():
    return ['RCE', 'SQLe', 'LFI', 'RFI']
```
If you have RCE, you should probably add lower impact as well to support as many `payloads` as possible.<br />

Every item returned here needs to be represented by a method.<br />
ie if you `return ['RCE']` you need to also `def rce(instructions, args):`

### is_auth_required()
Tell HackWP is this exploits needs authentication.<br />
ie HackWP can be used to both steal and use stolen cookies.<br />
If auth is required, HackWP will try to use stolen session cookies for all the request sent with this exploit.

**Sample definition**
```
def is_auth_required():
    return False
```
This means the exploit is unauthenticated.

### get_author()
Return the author of the exploit script

**Sample definition**
```
def get_author():
    return "@etragard"
```

### get_thanks()
Return special thanks

**Sample definition**
```
def get_thanks():
    return ["@smitka", "@renato"]
```


## Optional Methods Details

>[!CAUTION]
>args, args.verbose and args.silent is the same for all executing functions<br />
>And will not be mentioned again under every one

**param: args**

This is the HackWP argument that was passed to `~# hackwp` on the command line.<br />

`~# hackwp --target http://localhost` would be fetched here with `args.target`

**param: args.verbose**

Respect the verbose output.<br />
If it is `not` set, we dont need very verbose output please.

**param: args.silent**

Respect the silent mode.<br />
If it is set, dont output anything.<br />
However, you should still return so the "output" can be used by next function.

**Note**

The function or method will run once for every instruction in the payload.<br />
So you just need to handle the executing and return the proper output.

### rce(instruction, args) -> Remote Code Execution

**param: instructions**

PHP code, including opening and closing PHP-tags.<br />
This parameter is set by the payload. You just have to execute it.
```
<?php echo DB_PASSWORD; ?>
```

**return:**

You are supposed to return the output for the executed PHP.<br />
If there is no output. Dont output anything.

### lfi(instruction, args) -> Local File Inclusion

**param: instructions**
Path to file on target file system, to be viewed by attacker.
```
/etc/shadow
```

**return:**

Output the contents of the file
